(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[290],{420:(e,t,i)=>{Promise.resolve().then(i.bind(i,2445))},9730:(e,t,i)=>{"use strict";i.d(t,{A:()=>l});var n=i(2115),r=i(2784),a=function(){return(a=Object.assign||function(e){for(var t,i=1,n=arguments.length;i<n;i++)for(var r in t=arguments[i])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},o=function(e,t){var i={};for(r in e)Object.prototype.hasOwnProperty.call(e,r)&&0>t.indexOf(r)&&(i[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var n=0,r=Object.getOwnPropertySymbols(e);n<r.length;n++)0>t.indexOf(r[n])&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(i[r[n]]=e[r[n]]);return i},s=function(e){return"Typesetting failed: ".concat(void 0!==e.message?e.message:JSON.stringify(e))};let l=function(e){function t(){var e;"every"===y&&A&&"post"===v&&null!==j.current&&(j.current.style.visibility=null!=(e=null==(e=m.style)?void 0:e.visibility)?e:"visible"),_.current||("first"===y&&null!==j.current&&(j.current.style.visibility="visible"),h&&h(),_.current=!0),d&&d(),P.current=!1}var i=e.inline,l=void 0!==i&&i,i=e.hideUntilTypeset,h=e.onInitTypeset,d=e.onTypeset,c=e.text,u=e.dynamic,g=e.typesettingOptions,f=e.renderMode,p=e.children,m=o(e,["inline","hideUntilTypeset","onInitTypeset","onTypeset","text","dynamic","typesettingOptions","renderMode","children"]),x=(0,n.useRef)(""),j=(0,n.useRef)(null),w=(0,n.useContext)(r.k),y=null!=i?i:null==w?void 0:w.hideUntilTypeset,v=null!=f?f:null==w?void 0:w.renderMode,b=null!=g?g:null==w?void 0:w.typesettingOptions,A=!1!==u&&(u||!1),_=(0,n.useRef)(!1),P=(0,n.useRef)(!1);return!P.current&&null!==j.current&&A&&"every"===y&&"post"===v&&(j.current.style.visibility="hidden"),("undefined"!=typeof window?n.useLayoutEffect:n.useEffect)(function(){if((A||!_.current)&&null!==j.current){if(!w)throw Error("MathJax was not loaded, did you use the MathJax component outside of a MathJaxContext?");if("pre"===v){if(!("string"==typeof c&&0<c.length))throw Error("Render mode 'pre' requires text prop to be set and non-empty, which was currently \"".concat(c,'"'));if(!g||!g.fn)throw Error("Render mode 'pre' requires 'typesettingOptions' prop with 'fn' property to be set on MathJax element or in the MathJaxContext");if(2===w.version)throw Error("Render mode 'pre' only available with MathJax 3, and version 2 is currently in use")}"post"!==v&&c===x.current||P.current||(P.current=!0,3===w.version?w.promise.then(function(e){var i;"pre"===v?(i=function(i){x.current=c,e.startup.document.clear(),e.startup.document.updateDocument(),null!==j.current&&(j.current.innerHTML=i.outerHTML),t()},g.fn.endsWith("Promise")?e.startup.promise.then(function(){return e[b.fn](c,a(a({},(null==b?void 0:b.options)||{}),{display:!l}))}).then(i).catch(function(e){throw t(),Error(s(e))}):e.startup.promise.then(function(){i(e[b.fn](c,a(a({},(null==b?void 0:b.options)||{}),{display:!l})))}).catch(function(e){throw t(),Error(s(e))})):e.startup.promise.then(function(){return e.typesetClear([j.current]),e.typesetPromise([j.current])}).then(t).catch(function(e){throw t(),Error(s(e))})}).catch(function(e){throw t(),Error(s(e))}):w.promise.then(function(e){e.Hub.Queue(["Typeset",e.Hub,j.current]),e.Hub.Queue(t)}).catch(function(e){throw t(),Error(s(e))}))}}),n.createElement("span",a({},m,{style:a(a({display:l?"inline":"block"},m.style),{visibility:y?"hidden":null==(e=m.style)?void 0:e.visibility}),ref:j}),p)}},2784:(e,t,i)=>{"use strict";i.d(t,{A:()=>d,k:()=>s});var n,r,a=i(2115),o=function(){return(o=Object.assign||function(e){for(var t,i=1,n=arguments.length;i<n;i++)for(var r in t=arguments[i])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},s=(0,a.createContext)(void 0),l="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML",h="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js";let d=function(e){var t=e.config,i=e.version,i=void 0===i?3:i,d=e.src,d=void 0===d?2===i?l:h:d,c=e.onStartup,u=e.onLoad,g=e.asyncLoad,f=void 0!==g&&g,p=e.onError,g=e.typesettingOptions,m=e.renderMode,m=void 0===m?"post":m,x=e.hideUntilTypeset,e=e.children,j=(0,a.useContext)(s);if(void 0!==(null==j?void 0:j.version)&&(null==j?void 0:j.version)!==i)throw Error("Cannot nest MathJaxContexts with different versions. MathJaxContexts should not be nested at all but if they are, they cannot have different versions. Stick with one version of MathJax in your app and avoid using more than one MathJaxContext.");if(2===i&&void 0!==r||3===i&&void 0!==n)throw Error("Cannot use MathJax versions 2 and 3 simultaneously in the same app due to how MathJax is set up in the browser; either you have multiple MathJaxContexts with different versions or you have mounted and unmounted MathJaxContexts with different versions. Please stick with one version of MathJax in your app. File an issue in the project Github page if you need this feature.");var w=(0,a.useRef)(j),j=(0,a.useRef)((null==j?void 0:j.version)||null);if(null===j.current)j.current=i;else if(j.current!==i)throw Error("Cannot change version of MathJax in a MathJaxContext after it has mounted. Reload the page with a new version when this must happen.");var y=d||(2===i?l:h);function v(e,i){t&&(window.MathJax=t);var n=document.createElement("script");n.type="text/javascript",n.src=y,n.async=f,n.addEventListener("load",function(){var t=window.MathJax;c&&c(t),e(t),u&&u()}),n.addEventListener("error",function(e){return i(e)}),document.getElementsByTagName("head")[0].appendChild(n)}return void 0===w.current&&(j={typesettingOptions:g,renderMode:m,hideUntilTypeset:x},2===i?void 0===n&&("undefined"!=typeof window?(n=new Promise(v)).catch(function(e){if(!p)throw Error("Failed to download MathJax version 2 from '".concat(y,"' due to: ").concat(JSON.stringify(e)));p(e)}):(n=Promise.reject()).catch(function(e){})):void 0===r&&("undefined"!=typeof window?(r=new Promise(v)).catch(function(e){if(!p)throw Error("Failed to download MathJax version 3 from '".concat(y,"' due to: ").concat(e));p(e)}):(r=Promise.reject()).catch(function(e){})),w.current=o(o({},j),2===i?{version:2,promise:n}:{version:3,promise:r})),a.createElement(s.Provider,{value:w.current},e)}},5565:(e,t,i)=>{"use strict";i.d(t,{default:()=>r.a});var n=i(4146),r=i.n(n)},3018:e=>{!function(){"use strict";var t={114:function(e){function t(e){if("string"!=typeof e)throw TypeError("Path must be a string. Received "+JSON.stringify(e))}function i(e,t){for(var i,n="",r=0,a=-1,o=0,s=0;s<=e.length;++s){if(s<e.length)i=e.charCodeAt(s);else if(47===i)break;else i=47;if(47===i){if(a===s-1||1===o);else if(a!==s-1&&2===o){if(n.length<2||2!==r||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2)){if(n.length>2){var l=n.lastIndexOf("/");if(l!==n.length-1){-1===l?(n="",r=0):r=(n=n.slice(0,l)).length-1-n.lastIndexOf("/"),a=s,o=0;continue}}else if(2===n.length||1===n.length){n="",r=0,a=s,o=0;continue}}t&&(n.length>0?n+="/..":n="..",r=2)}else n.length>0?n+="/"+e.slice(a+1,s):n=e.slice(a+1,s),r=s-a-1;a=s,o=0}else 46===i&&-1!==o?++o:o=-1}return n}var n={resolve:function(){for(var e,n,r="",a=!1,o=arguments.length-1;o>=-1&&!a;o--)o>=0?n=arguments[o]:(void 0===e&&(e=""),n=e),t(n),0!==n.length&&(r=n+"/"+r,a=47===n.charCodeAt(0));return(r=i(r,!a),a)?r.length>0?"/"+r:"/":r.length>0?r:"."},normalize:function(e){if(t(e),0===e.length)return".";var n=47===e.charCodeAt(0),r=47===e.charCodeAt(e.length-1);return(0!==(e=i(e,!n)).length||n||(e="."),e.length>0&&r&&(e+="/"),n)?"/"+e:e},isAbsolute:function(e){return t(e),e.length>0&&47===e.charCodeAt(0)},join:function(){if(0==arguments.length)return".";for(var e,i=0;i<arguments.length;++i){var r=arguments[i];t(r),r.length>0&&(void 0===e?e=r:e+="/"+r)}return void 0===e?".":n.normalize(e)},relative:function(e,i){if(t(e),t(i),e===i||(e=n.resolve(e))===(i=n.resolve(i)))return"";for(var r=1;r<e.length&&47===e.charCodeAt(r);++r);for(var a=e.length,o=a-r,s=1;s<i.length&&47===i.charCodeAt(s);++s);for(var l=i.length-s,h=o<l?o:l,d=-1,c=0;c<=h;++c){if(c===h){if(l>h){if(47===i.charCodeAt(s+c))return i.slice(s+c+1);if(0===c)return i.slice(s+c)}else o>h&&(47===e.charCodeAt(r+c)?d=c:0===c&&(d=0));break}var u=e.charCodeAt(r+c);if(u!==i.charCodeAt(s+c))break;47===u&&(d=c)}var g="";for(c=r+d+1;c<=a;++c)(c===a||47===e.charCodeAt(c))&&(0===g.length?g+="..":g+="/..");return g.length>0?g+i.slice(s+d):(s+=d,47===i.charCodeAt(s)&&++s,i.slice(s))},_makeLong:function(e){return e},dirname:function(e){if(t(e),0===e.length)return".";for(var i=e.charCodeAt(0),n=47===i,r=-1,a=!0,o=e.length-1;o>=1;--o)if(47===(i=e.charCodeAt(o))){if(!a){r=o;break}}else a=!1;return -1===r?n?"/":".":n&&1===r?"//":e.slice(0,r)},basename:function(e,i){if(void 0!==i&&"string"!=typeof i)throw TypeError('"ext" argument must be a string');t(e);var n,r=0,a=-1,o=!0;if(void 0!==i&&i.length>0&&i.length<=e.length){if(i.length===e.length&&i===e)return"";var s=i.length-1,l=-1;for(n=e.length-1;n>=0;--n){var h=e.charCodeAt(n);if(47===h){if(!o){r=n+1;break}}else -1===l&&(o=!1,l=n+1),s>=0&&(h===i.charCodeAt(s)?-1==--s&&(a=n):(s=-1,a=l))}return r===a?a=l:-1===a&&(a=e.length),e.slice(r,a)}for(n=e.length-1;n>=0;--n)if(47===e.charCodeAt(n)){if(!o){r=n+1;break}}else -1===a&&(o=!1,a=n+1);return -1===a?"":e.slice(r,a)},extname:function(e){t(e);for(var i=-1,n=0,r=-1,a=!0,o=0,s=e.length-1;s>=0;--s){var l=e.charCodeAt(s);if(47===l){if(!a){n=s+1;break}continue}-1===r&&(a=!1,r=s+1),46===l?-1===i?i=s:1!==o&&(o=1):-1!==i&&(o=-1)}return -1===i||-1===r||0===o||1===o&&i===r-1&&i===n+1?"":e.slice(i,r)},format:function(e){var t,i;if(null===e||"object"!=typeof e)throw TypeError('The "pathObject" argument must be of type Object. Received type '+typeof e);return t=e.dir||e.root,i=e.base||(e.name||"")+(e.ext||""),t?t===e.root?t+i:t+"/"+i:i},parse:function(e){t(e);var i,n={root:"",dir:"",base:"",ext:"",name:""};if(0===e.length)return n;var r=e.charCodeAt(0),a=47===r;a?(n.root="/",i=1):i=0;for(var o=-1,s=0,l=-1,h=!0,d=e.length-1,c=0;d>=i;--d){if(47===(r=e.charCodeAt(d))){if(!h){s=d+1;break}continue}-1===l&&(h=!1,l=d+1),46===r?-1===o?o=d:1!==c&&(c=1):-1!==o&&(c=-1)}return -1===o||-1===l||0===c||1===c&&o===l-1&&o===s+1?-1!==l&&(0===s&&a?n.base=n.name=e.slice(1,l):n.base=n.name=e.slice(s,l)):(0===s&&a?(n.name=e.slice(1,o),n.base=e.slice(1,l)):(n.name=e.slice(s,o),n.base=e.slice(s,l)),n.ext=e.slice(o,l)),s>0?n.dir=e.slice(0,s-1):a&&(n.dir="/"),n},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,e.exports=n}},i={};function n(e){var r=i[e];if(void 0!==r)return r.exports;var a=i[e]={exports:{}},o=!0;try{t[e](a,a.exports,n),o=!1}finally{o&&delete i[e]}return a.exports}n.ab="//";var r=n(114);e.exports=r}()},4146:(e,t,i)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var i in t)Object.defineProperty(e,i,{enumerable:!0,get:t[i]})}(t,{default:function(){return l},getImageProps:function(){return s}});let n=i(306),r=i(666),a=i(7970),o=n._(i(5514));function s(e){let{props:t}=(0,r.getImgProps)(e,{defaultLoader:o.default,imgConf:{deviceSizes:[640,750,828,1080,1200,1920,2048,3840],imageSizes:[16,32,48,64,96,128,256,384],path:"/_next/image",loader:"default",dangerouslyAllowSVG:!1,unoptimized:!1}});for(let[e,i]of Object.entries(t))void 0===i&&delete t[e];return{props:t}}let l=a.Image},2445:(e,t,i)=>{"use strict";i.r(t),i.d(t,{default:()=>f});var n=i(5155),r=i(3018),a=i.n(r),o=i(8989),s=i(9727),l=i(1109),h=i(2723),d=i(5565),c=i(9730);let u=a().join("/projects/ImageProcessing/Project4/","media"),g=[{id:"Homographies",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Recovering the Homographies"}),(0,n.jsxs)("p",{children:["A homography is given by a transformation sending"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(v_{1} = \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\)"})," ","to"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(v_{2} = \\begin{bmatrix} x^{\\prime} \\\\ y^{\\prime} \\\\ 1 \\end{bmatrix}\\)"})," ","mod scaling through a matrix:",(0,n.jsx)(c.A,{children:"\\begin{equation*} c \\begin{bmatrix} x^{\\prime} \\\\ y^{\\prime} \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} h_{1} & h_{2} & h_{3} \\\\ h_{4} & h_{5} & h_{6} \\\\ h_{7} & h_{8} & 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} \\end{equation*}"}),"Multiplying everything out, we get:",(0,n.jsx)(c.A,{children:"\\begin{align*} cx^{\\prime} &= h_{1}x + h_{2}y + h_{3} \\\\ cy^{\\prime} &= h_{4}x + h_{5}y + h_{6} \\\\ c &= h_{7}x + h_{8}y + 1 \\end{align*}"}),"and substituting:",(0,n.jsx)(c.A,{children:"\\begin{align*} (h_{7}x + h_{8}y + 1)x^{\\prime} &= h_{1}x + h_{2}y + h_{3} \\\\ (h_{7}x + h_{8}y + 1)y^{\\prime} &= h_{4}x + h_{5}y + h_{6} \\end{align*}"}),"will give the system of equations:",(0,n.jsx)(c.A,{children:"\\begin{align*} h_{1}x + h_{2}y + h_{3} + 0h_{4} + 0h_{5} + 0h_{6} - h_{7}xx^{\\prime} - h_{8}yx^{\\prime} - 1x^{\\prime} &= 0 \\\\ 0h_{1} + 0h_{2} + 0h_{3} + h_{4}x + h_{5}y + h_{6} - h_{7}xy^{\\prime} - h_{8}yy^{\\prime} - 1y^{\\prime} &= 0 \\end{align*}"}),"This gives a way to solve for the entries of the matrix"," ",(0,n.jsx)(c.A,{inline:!0,children:"H"})," through a different linear equation ",(0,n.jsx)(c.A,{inline:!0,children:"\\(Ax = b\\)"})," where"," ",(0,n.jsxs)(c.A,{inline:!0,children:["\\(A\\)"," "]})," is a"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(2 \\times 8\\)"})," matrix,",(0,n.jsx)(c.A,{inline:!0,children:"x "})," is the vector containing the entries ",(0,n.jsx)(c.A,{inline:!0,children:"\\(h_1, \\ldots, h_8\\)"}),", and ",(0,n.jsx)(c.A,{inline:!0,children:"\\(b\\)"})," is the vector containing the values"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(x', y'\\)"}),". This is extendable to include more points in our homography mapping and can be solved through least squares to find the projective mapping"]}),(0,n.jsx)("p",{children:"Here is an example of the point correspondences that I used to compute the homography"}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part1/kps1.png"),alt:"kps1",width:"913",height:"325",loading:"lazy"})})]})},{id:"Image Warping",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Warping the Image"}),(0,n.jsxs)("p",{children:["This process was very similar to the last project, but instead, the warp would be determined by four corners under the homography transformation. After calculating the new corners, a resulting image would be set to encompass the warped image. The pixel values in the new image ",(0,n.jsx)(c.A,{inline:!0,children:"\\(B\\)"})," would be determined by where the pixel landed under the transformation"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(H^{-1}\\)"})]}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part1/inverseWarp.svg"),alt:"inverseWarp",width:"560",height:"380",loading:"lazy"})}),(0,n.jsxs)("p",{children:["Since the pixel location under $H^",-1,"$ is not exact, I used griddata to interpolate for the pixel value using the location and values in the original image as the data. Here is the result of the warp on the left and the base image of the panorama on the right"]}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part1/homography1.png"),alt:"homography1",width:"900",height:"370",loading:"lazy"})})]})},{id:"Rectification",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Rectification"}),(0,n.jsx)("p",{children:"One interesting application of image warping by homography is to emulate a snapshot of the image from a different perspective. In changing the camera angle via homography, we attempt to capture the pixels outside the image, and therefore, the image is shifted further to the peripheral making it seem distorted. This is why rectification will work well when dealing with small shifts in the perspective. Here are some examples that I ran my code on:"}),(0,n.jsxs)(h.V,{columns:2,children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part1/rectified/book_original.png"),loading:"lazy",width:"950",height:"640",alt:"PreRectified book"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/rectified/book_rectified.png"),loading:"lazy",width:"1600",height:"1000",alt:"Rectified book"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/rectified/sign_original.png"),loading:"lazy",width:"660",height:"800",alt:"PreRectified sign"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/rectified/sign_rectified.png"),loading:"lazy",width:"3200",height:"1600",alt:"Rectified Sign"})]})]})},{id:"Image Mosaic",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Image Mosaic"}),(0,n.jsx)("p",{children:"The first step is to correctly align the images. Here I used zero padding:"}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part1/padded_homography.png"),alt:"padded_homography",width:"550",height:"200",loading:"lazy"})}),(0,n.jsxs)("p",{children:["The images cannot be directly added together and averaged at the intersection because there is different lighting and exposure across images. To fix this, I created a set of two images. Let the image on the left be image ",(0,n.jsx)(c.A,{inline:!0,children:"\\(A\\)"})," and the image on the right be image"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(B\\)"}),". In one image, image"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(A\\)"})," would dominate, meaning that on"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(\\text{image}(A) \\cap \\text{image} B\\)"}),", I would set the pixel values to be that of image"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(A\\)"}),". The other case would be an image where image ",(0,n.jsx)(c.A,{inline:!0,children:"\\(B\\)"})," ","dominates. Here is an example of creating these images:"]}),(0,n.jsxs)(h.V,{children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part1/blending/im1dominant.png"),width:"1000",height:"250",alt:"im1dominant",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/blending/im2dominant.png"),alt:"im2dominant",width:"500",height:"140",loading:"lazy"})]}),(0,n.jsxs)("p",{children:["Then for the blending, notice that image"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(A\\)"})," captures the scene more accurately the closer the pixels are to the center of image"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(A\\)"}),". The same goes for image"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(B\\)"}),". So to get a blend, a linear interpolation between their centers can be calculated (through griddata) and put into a mask. The output image is given by",(0,n.jsx)(c.A,{children:"\\begin{equation*} \\text{mosaic} = \\text{mask} \\cdot \\text{dominantA} + (1 - \\text{mask}) \\cdot \\text{dominantB} \\end{equation*}"}),"Here is an iterative approach to the blending:"]}),(0,n.jsxs)(h.V,{columns:2,children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part1/blending/blend0.jpeg"),alt:"blend0",width:"430",height:"560",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/blending/blend1.jpeg"),alt:"blend1",width:"400",height:"467",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/blending/blend2.jpeg"),alt:"blend2",width:"380",height:"410",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part1/blending/blend3.jpeg"),alt:"blend3",width:"480",height:"480",loading:"lazy"})]}),(0,n.jsx)("p",{children:"Although it is possible to separate the frequencies into high and low frequencies, blending the lower frequencies and choosing one of the higher frequencies, I had more success just directly blending the images. This is because a small misalignment of about 5 pixels can cause the high frequencies in one image to look discontinuous with the high frequencies in the other. This caused the railing to look cutoff at certain areas in my previous blends. Here is the final result without separating the frequencies:"}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part1/mosaic.png"),width:"6900",height:"3000",alt:"mosaic",loading:"lazy"})})]})},{id:"Corner Detection",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Detecting Corner Features"}),(0,n.jsxs)("p",{children:["The Harris corner detector defines a corner centered on pixel"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(u, v\\)"})," on some window of size"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(w\\)"})," if for any shift in"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(x\\)"})," or"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(y\\)"}),", the squared difference between the shifted window and the original is non-zero."]}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part2/harris_corner_def.svg"),width:"1120",height:"800",alt:"harris corner def",loading:"lazy"})}),(0,n.jsxs)("p",{children:["We notice that when the red window is over a monocolor surface, shifts of the window in either the"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(x\\)"})," or"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(y\\)"})," direction results in no change in what the window sees. For the line example, the window only sees a change when we move in the vertical direction. When the window is shifted in a horizontal direction, the difference is"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(0\\)"}),". This would be defined as an edge. Finally, we have the vertex of a triangle. In this case, any change in either the ",(0,n.jsx)(c.A,{inline:!0,children:"\\(x\\)"}),"or ",(0,n.jsx)(c.A,{inline:!0,children:"\\(y\\)"})," direction results in a change in what the window sees. We can also plot the squared difference as a function over displacement of the window at a pixel. Here's what it would look like for the above examples:"]}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part2/corner_diff.svg"),width:"1120",height:"800",alt:"window differences",loading:"lazy"})}),(0,n.jsxs)("p",{children:["The first one is circular because at the origin, displacement is,"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\((0, 0)\\)"})," and as we have more displacement, the error increases between the original and the displaced window. The second one is like a valley because along the horizontal direction, displacement does not change what the window sees, so the error is ",(0,n.jsx)(c.A,{inline:!0,children:"\\(0\\)"}),". As we move in the vertical direction, the error increase. Finally, if the window is over a monocolor surface, the error will be"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(0\\)"}),"."]}),(0,n.jsx)("p",{children:"Implementation of finding the harris corners and corner strength was given as starter code. Also, I was not able to plot all harris corners because there were too many detected, and it would completely blanket the image. A view of some of the filtered out corners will be shown in the next section."})]})},{id:"Feature Descriptors",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Extracting Feature Descriptors"}),(0,n.jsxs)("p",{children:["Feature descriptors describe what is happening locally at a pixel. They usually small"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(8 \\times 8\\)"})," pixels, and can be used to match features across images. This is done by the squared difference between the descriptors. At the original resolution, however, the descriptors are not robust to small errors such as differences in orientation and perspective. To fix this, a"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(40 \\times 40\\)"})," window is sampled around the pixel, convolved with a Gaussian kernel, and downsampled by ",(0,n.jsx)(c.A,{inline:!0,children:"\\(5\\)"}),". The descriptor is finally normalized to make it resilient to differences in luminence:"]}),(0,n.jsxs)(h.V,{children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/feat_desc.jpg"),width:"2300",height:"900",alt:"feature descriptor bush",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/feat_desc2.jpg"),alt:"feature descriptor building",width:"800",height:"2100",loading:"lazy"})]}),(0,n.jsx)("p",{children:"And here are all the feature descriptors extracted from the images:"}),(0,n.jsxs)(h.V,{columns:2,children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/feat_desc_left.jpg"),width:"1250",height:"980",alt:"doe descriptor left",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/feat_desc_right.jpg"),width:"1150",height:"850",alt:"doe descriptor right",loading:"lazy"})]})]})},{id:"Feature Matching",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Feature Matching"}),(0,n.jsx)("p",{children:"Notice that in the previous picture, some feature descriptors in one image are not present in the other. So we need a way to throw away feature descriptors as well as match the remaining feature descriptors. One problem with finding the nearest neighbor from one image to another by squared error is that two descriptors could yield a small error, but the probability of it being an incorrect match shares significant overlap with the probability that it is a correct match:"}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part2/nn_matching.jpg"),width:"1850",height:"850",alt:"nearest neighbor matching error",loading:"lazy"})}),(0,n.jsxs)("p",{children:["This is seen on the left where a nearest neighbor squared error of"," ",(0,n.jsx)(c.A,{inline:!0,children:"\\(10\\)"})," will not be a strong indicator of whether the pair is a correct match or not. One instance in which this might be a problem is if the descriptors are not present in both images. In the case that the descriptor from one image matches with the descriptor in the other, we have an outlier match, which will throw off the key point matching."]}),(0,n.jsx)("p",{children:"In contrast, we can instead look at the ratio between the closest match and the second closest match error. This gives a much better separation between the probability density of correct matches vs incorrect matches. The algorithm is reduce to setting the threshold. If the ratio of the error is high, then we can reject both descriptors as being a part of the final match. If the ratio is low, then we have found a match between the descriptor and its nearest neighbor."}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part2/doe_matching.jpg"),width:"1900",height:"780",alt:"Doe feature matching",loading:"lazy"})}),(0,n.jsx)("p",{children:"Here, the white feature descriptors are from before feature matching. The red is after feature matching. Notice that the feature descriptors that are preserved tend to be on the overlap region of the two images."})]})},{id:"Robust Homography",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"Robust Homography"}),(0,n.jsx)("p",{children:"All that is left is to produce the homography. One problem we have is that many of the feature descriptors do not represent a true match. For example, in the right image below, there is a red feature descriptor in the bottom right corner, which clearly lies outside of the image on the left. To make the homography robust to incorrect matches, we can use the RANSAC method."}),(0,n.jsx)(h.V,{children:(0,n.jsx)(d.default,{src:a().join(u,"/Part2/feat_corres.jpg"),width:"1800",height:"700",alt:"feature correspondences",loading:"lazy"})}),(0,n.jsx)("p",{children:"RANSAC is a statistical algorithm which, for a chosen set of data, finds the inliers and outliers given our distribution. In our example, given four points which define a homography, we want to see how likely the homography on these points is to be the true homography. To do this, we compute the homography on the four points, and for every other point in the same image, we apply the homography. We then see if its matching feature descriptor lie within half a pixel of each other. If they do, then we classify them as an inlier, meaning they agree with the homography, otherwise, they are an outlier. The problem then reduces to choosing the homography that maximizes the number of inliers."}),(0,n.jsxs)(h.V,{columns:3,children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/doe/doeleft.jpg"),width:"1500",height:"1125",alt:"doe left",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/doe/doemiddle.jpg"),width:"1500",height:"1125",alt:"doe middle",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/doe/doeright.jpg"),width:"1500",height:"1125",alt:"doe right",loading:"lazy"})]}),(0,n.jsxs)(h.V,{columns:2,children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/doe/doe1.jpg"),width:"1690",height:"1250",alt:"doe first homography",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/doe/doe2.jpg"),width:"1900",height:"1000",alt:"doe second homography",loading:"lazy"})]})]})},{id:"Final Results",content:(0,n.jsxs)("div",{children:[(0,n.jsx)("h2",{children:"A Comparison"}),(0,n.jsx)("p",{children:"Here are the results of the homography done manually vs automatically. The image on top will be the one doe manually and the one below is automatic. There is a noticeable trend that the automatic alignment and robust homography tends to do better in areas that have lots of trees. In the examples below, my manual alignment tends to result in the leaves being blurred, while the automatic alignment is much more consistent in aligning the leaves."}),(0,n.jsx)("h4",{children:"Near Anthropology"}),(0,n.jsxs)(h.V,{children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/anthro/anthro.jpg"),width:"3700",height:"1950",alt:"anthro manual",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/anthro/anthro_ransac.jpg"),width:"3800",height:"1950",alt:"anthro auto",loading:"lazy"})]}),(0,n.jsx)("h4",{children:"Street Intersection"}),(0,n.jsxs)(h.V,{children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/intersection/inter.jpg"),width:"3000",height:"1600",alt:"intersection manual",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/intersection/inter_ransac.jpg"),width:"3000",height:"1600",alt:"intersection auto",loading:"lazy"})]}),(0,n.jsx)("h4",{children:"Faculty Glade"}),(0,n.jsxs)(h.V,{children:[(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/glade/glade.jpg"),width:"3000",height:"1600",alt:"glade manual",loading:"lazy"}),(0,n.jsx)(d.default,{src:a().join(u,"/Part2/results/glade/glade_ransac.jpg"),width:"3500",height:"1800",alt:"glade auto",loading:"lazy"})]})]})}];function f(){return(0,n.jsxs)("div",{children:[(0,n.jsx)(o.l,{children:(0,n.jsx)("h1",{children:"Project 4: Image Warping and Mosaicing"})}),(0,n.jsx)(s.LN,{children:(0,n.jsxs)(s.J3,{children:[(0,n.jsx)(s.nA,{children:g.map(e=>(0,n.jsx)(s.wn,{children:(0,n.jsx)(s.n9,{id:e.id,link:e.link,children:e.content})},e.id))}),(0,n.jsx)(l.B,{ids:g.map(e=>e.id)})]})})]})}},8989:(e,t,i)=>{"use strict";i.d(t,{l:()=>r});var n=i(5155);let r=e=>{let{children:t}=e;return(0,n.jsx)("div",{className:"text-center text-black p-20 row-span-2 row-start-1 row-end-2 flex flex-col flex-nowrap justify-center items-center w-full",children:t})}},9727:(e,t,i)=>{"use strict";i.d(t,{J3:()=>c,LN:()=>u,n9:()=>l,nA:()=>h,wn:()=>d});var n=i(5155),r=i(8173),a=i.n(r),o=i(9795);let s=(e,t)=>(0,n.jsx)(a(),{href:e,className:"z-10 block absolute top-0 ".concat(t?"":"max-w-[95%]"," w-full h-full bg-black rounded-2xl text-white ").concat(t?"hover:scale-x-105 hover:translate-x-[2%]  hover:translate-y-[4%]":"hover:translate-x-[2%]"," transform ease-in-out duration-200"),children:(0,n.jsx)("div",{className:"flex flex-row w-full h-full items-center justify-end ",children:(0,n.jsx)("div",{className:"w-[8%]",children:"âž§"})})}),l=e=>{let{id:t,link:i,orientation:r,className:a,children:l}=e;return(0,n.jsxs)("div",{className:"h-fit",children:[(0,n.jsx)("article",{className:(0,o.QP)("relative z-50 m-0 p-8 text-left ".concat(r?"max-h-[90%] w-full":"max-w-[85%] h-full"," ").concat(i?"":"max-w-[100%]"," h-fit rounded-2xl bg-white text-black ").concat(a)),id:t,children:l}),i?s(i,r):""]})},h=e=>{let{children:t}=e;return(0,n.jsx)("div",{className:"flex flex-col flex-grow max-w-[60rem]",children:t})},d=e=>{let{children:t,className:i}=e;return(0,n.jsx)("section",{className:(0,o.QP)("mb-8 mx-[5vw] rounded-[1rem] shadow-[0px_5px_15px_rgba(0,0,0,0.35)] h-fit relative bg-red ".concat(i)),children:t})},c=e=>{let{children:t}=e;return(0,n.jsx)("div",{className:"flex flex-row flex-nowrap justify-center relative",children:t})},u=e=>{let{children:t}=e;return(0,n.jsx)("div",{className:"mx-[5vw]",children:t})}},2723:(e,t,i)=>{"use strict";i.d(t,{D:()=>o,V:()=>s});var n=i(5155),r=i(2115),a=i(9795);let o=e=>{let{children:t}=e;return(0,n.jsx)("figure",{children:r.Children.map(t,e=>r.isValidElement(e)&&"string"!=typeof e.type?r.cloneElement(e,{className:(0,a.QP)(e.props.className,"w-full text-center")}):e)})},s=e=>{let{columns:t=1,className:i,children:o}=e;return(0,n.jsx)("div",{className:(0,a.QP)("grid ".concat(["grid-cols-0","grid-cols-1","grid-cols-2","grid-cols-3","grid-cols-4","grid-cols-5","grid-cols-6","grid-cols-7","grid-cols-8"][t]," gap-4 items-center justify-center w-full max-w-[90%] mx-auto py-4 ").concat(i," ")),children:r.Children.map(o,e=>r.isValidElement(e)&&"string"!=typeof e.type?r.cloneElement(e,{className:(0,a.QP)(e.props.className,"w-full")}):e)})}},1109:(e,t,i)=>{"use strict";i.d(t,{B:()=>r});var n=i(5155);let r=e=>{let{ids:t,children:i}=e;return(0,n.jsx)("div",{className:"block flex-grow",children:(0,n.jsxs)("div",{className:"max-w-[80%] mx-auto h-full",children:[i,t?(0,n.jsx)("div",{className:"sticky top-[20%] p-4 pl-6 border-1 border-black border-solid rounded-[1rem] bg-black shadow-[0px_5px_15px_rgba(0,0,0,0.35)] h-auto  max-h-[60vh] overflow-y-auto ",children:(0,n.jsx)("nav",{children:t.map(e=>(0,n.jsx)("ul",{children:(0,n.jsx)("a",{className:"block scale-90 hover:text-slate-300 transition-transform  duration-100 ease-in-out text-[1.1rem] hover:scale-100 focus:scale-100 ",href:"#".concat(e),children:e})},e))})}):(0,n.jsx)("div",{})]})})}}},e=>{var t=t=>e(e.s=t);e.O(0,[173,795,970,441,517,358],()=>t(420)),_N_E=e.O()}]);